%{

#include <stdio.h>
#include <string>
#include <vector>

#include "include/ast.hpp"

%}

%require "2.3"

%debug

%start program

%defines

%skeleton "lalr1.cc"

%name-prefix="lury"

%define "parser_class_name" "Parser"

%locations
%initial-action
{
	@$.begin.filename = @$.end.filename = &driver.streamname;
};

%parse-param { class Driver& driver }

%error-verbose

%union {
	int int_value;
	double double_value;
	std::string *string_value;
	class AST *ast;
	std::vector<std::string> *param_list;
	vector<AST *> *arg_list;
	int level_diff;
}

/* Whitespace */
%token NewLine Indent Dedent
%token END 0 "end of file"

/* ContextualKeyword */
%token
	IdentifierGet
	IdentifierSet
	IdentifierFile
	IdentifierLine
	IdentifierExit
	IdentifierSuccess
	IdentifierFailure

/* Keyword */
%token
	KeywordAbstract
	KeywordAnd
	KeywordBreak
	KeywordCase
	KeywordCatch
	KeywordClass
	KeywordContinue
	KeywordDef
	KeywordDefault
	KeywordDelete
	KeywordElif
	KeywordElse
	KeywordEnum
	KeywordExtended
	KeywordFalse
	KeywordFinally
	KeywordFor
	KeywordIf
	KeywordImport
	KeywordIn
	KeywordInterface
	KeywordInvariant
	KeywordIs
	KeywordLazy
	KeywordNameof
	KeywordNew
	KeywordNil
	KeywordNot
	KeywordOr
	KeywordOut
	KeywordOverride
	KeywordPass
	KeywordPrivate
	KeywordProperty
	KeywordProtected
	KeywordPublic
	KeywordRef
	KeywordReflect
	KeywordReturn
	KeywordScope
	KeywordSealed
	KeywordStatic
	KeywordSuper
	KeywordSwitch
	KeywordThis
	KeywordThrow
	KeywordTrue
	KeywordTry
	KeywordUnittest
	KeywordUnless
	KeywordUntil
	KeywordVar
	KeywordWhile
	KeywordWith
	KeywordYield

/* Operator */
%token
	AndShort
	AnnotationReturn
	AssignmentAdd
	AssignmentAnd
	AssignmentConcat
	AssignmentDivide
	AssignmentIntDivide
	AssignmentLeftShift
	AssignmentModulo
	AssignmentMultiply
	AssignmentOr
	AssignmentPower
	AssignmentRightShift
	AssignmentSub
	AssignmentXor
	Decrement
	Equal
	Increment
	IntDivide
	IsNot
	Lambda
	LeftShift
	LessThan
	MoreThan
	NilCoalesce
	NotEqual
	NotIn
	OrShort
	Power
	RangeClose
	RangeOpen
	RightShift

/* Identifier */
%token <string_value> Identifier

/* Literal */
%token EmbedStringLiteral WysiwygStringLiteral
%token <double_value> ImaginaryNumber
%token <double_value> FloatNumber
%token <int_value> Integer
%token <string_value> StringLiteral

%type <ast> statement statement_list statements program_line program_lines simple_statement simple_statements multiplication_expression unary_expression
%type <ast> power_expression addition_expression expression postfix_expression expression_statement
%type <ast> literal primary range_expression comparison_expression
%type <ast> program bool_not_expression bool_and_expression or_expression
%type <ast> if_statement elif_statements else_statement suite while_statement unless_statement
%type <ast> return_statement continue_statement break_statement
%type <ast> identifier_all lambda_expression lambda_body generator_expression
%type <ast> assignment_expression comma_expression conditional_expression bool_or_expression
%type <ast> function_definition argument class_definition pass_statement
%type <ast> xor_expression and_expression shift_expression callref_expression
%type <param_list> parameter_list
%type <string_value> parameter function_name class_name
%type <arg_list> argument_list

%left  ','
%right '=' AssignmentPower AssignmentMultiply AssignmentDivide AssignmentIntDivide AssignmentModulo AssignmentAdd AssignmentSub AssignmentConcat AssignmentOr AssignmentAnd AssignmentXor AssignmentLeftShift AssignmentRightShift
%right '?' ':' KeywordIf KeywordElse
%left  OrShort KeywordOr
%left  AndShort KeywordAnd
%right '!' KeywordNot
%left  Equal NotEqual '<' '>' LessThan MoreThan KeywordIs IsNot
%left  '|'
%left  '^'
%left  '&'
%left  LeftShift RightShift
%left  '+' '-' '~'
%left  '*' IntDivide '/' '%'
%right Power
%right Increment Decrement
%left  '.'

%{

#include "include/driver.hpp"
#include "include/scanner.hpp"

/* this "connects" the bison parser in the driver to the flex scanner class
 * object. it defines the yylex() function call to pull the next token from the
 * current lexer object of the driver context. */
#undef yylex
#define yylex driver.lexer->lex

%}

%%
program
	:
	{
		$$ = new CompoundAST();
		driver.ast = $$;
	}
	| program_lines
	{
		driver.ast = $1;
		$$ = $1;
	}

program_lines
	: program_line
	{
		$$ = new CompoundAST($1);
	}
	| program_lines program_line
	{
		((CompoundAST *) $1)->push_back($2);
		$$ = $1;
	}

program_line
	: statement
	| NewLine
	{
		$$ = new EmptyAST();
	}

statement
	: statement_list NewLine
	| if_statement
	| unless_statement
	| while_statement
	| function_definition
	| class_definition

statement_list
	: simple_statement
	| simple_statement simple_statements
	{
		((CompoundAST *) $2)->push_front($1);
		$$ = $2;
	}

simple_statement
	: expression_statement
	| return_statement
	| break_statement
	| continue_statement
	| pass_statement

simple_statements
	: ';'
	{
		$$ = new CompoundAST();
	}
	| ';' simple_statement
	{
		$$ = new CompoundAST($2);
	}
	| ';' simple_statement simple_statements
	{
		((CompoundAST *) $3)->push_front($2);
		$$ = $3;
	}

suite
	: statement_list NewLine
	{
		$$ = $1;
	}
	| NewLine Indent statements Dedent
	{
		$$ = $3;
	}

statements
	: statement
	{
		$$ = new CompoundAST($1);
	}
	| statements statement
	{
		((CompoundAST *) $1)->push_back($2);
		$$ = $1;
	}

if_statement
	: KeywordIf expression ':' suite
	{
		$$ = new IfStatementAST($2, $4);
	}
	| KeywordIf expression ':' suite elif_statements
	{
		$$ = new IfStatementAST($2, $4, $5);
	}

elif_statements
	: KeywordElif expression ':' suite
	{
		$$ = new IfStatementAST($2, $4);
	}
	| KeywordElif expression ':' suite elif_statements
	{
		$$ = new IfStatementAST($2, $4, $5);
	}
	| else_statement

else_statement
	: KeywordElse ':' suite
	{
		$$ = $3;
	}

unless_statement
	: KeywordUnless expression ':' suite
	{
		$$ = new IfStatementAST(new NotAST($2), $4);
	}
	| KeywordUnless expression ':' suite else_statement
	{
		$$ = new IfStatementAST(new NotAST($2), $4, $5);
	}

while_statement
	: KeywordWhile expression ':' suite
	{
		$$ = new WhileStatementAST($2, $4, NULL);
	}
	| KeywordWhile expression ':' suite else_statement
	{
		$$ = new WhileStatementAST($2, $4, $5);
	}

function_definition
	: KeywordDef function_name ':' suite
	{
		$$ = new FunctionStatementAST(*$2, $4);
		delete $2;
	}
	| KeywordDef function_name '(' ')' ':' suite
	{
		$$ = new FunctionStatementAST(*$2, $6);
		delete $2;
	}
	| KeywordDef function_name '(' parameter_list ')'':' suite
	{
		$$ = new FunctionStatementAST(*$2, *$4, $7);
		delete $2;
		delete $4;
	}

function_name
	: Identifier

parameter_list
	: parameter
	{
			vector<string> *list = new vector<string>();
			list->push_back(*$1);
			$$ = list;
			delete $1;
	}
	| parameter_list ',' parameter
	{
			vector<string> *list = $1;
			list->push_back(*$3);
			$$ = list;
			delete $3;
	}

parameter
	: Identifier

class_definition
	: KeywordClass class_name ':' suite
	{
		$$ = new ClassStatementAST(*$2, $4);
		delete $2;
	}

class_name
	: Identifier

pass_statement
	: KeywordPass
	{
		$$ = new NilLitAST();
	}

return_statement
	: KeywordReturn
	{
		$$ = new ReturnStatementAST(new NilLitAST());
	}
	| KeywordReturn expression_statement
	{
		$$ = new ReturnStatementAST($2);
	}

break_statement
	: KeywordBreak
	{
		$$ = new BreakStatementAST();
	}

continue_statement
	: KeywordContinue
	{
		$$ = new ContinueStatementAST();
	}

identifier_all
	: Identifier
	{
		$$ = new IdentifierAST(*$1);
	}

expression_statement
	: expression

expression
	: assignment_expression

assignment_expression
	: comma_expression
	| assignment_expression '=' comma_expression
	{
		$$ = new BinaryAssignAST($1, $3, OpEqual);
	}
	| assignment_expression AssignmentAdd comma_expression
	{
		$$ = new BinaryAssignAST($1, $3, OpAdd);
	}
	| assignment_expression AssignmentSub comma_expression
	{
		$$ = new BinaryAssignAST($1, $3, OpSub);
	}
	| assignment_expression AssignmentMultiply comma_expression
	{
		$$ = new BinaryAssignAST($1, $3, OpMul);
	}
	| assignment_expression AssignmentDivide comma_expression
	{
		$$ = new BinaryAssignAST($1, $3, OpDiv);
	}

comma_expression
	: generator_expression

generator_expression
	: lambda_expression

lambda_expression
	: conditional_expression
	| Lambda '(' lambda_body ')'
	{
		vector<string> params;
		$$ = new LambdaLitAST(params, $3);
	}
	| Lambda parameter_list '(' lambda_body ')'
	{
		$$ = new LambdaLitAST(*$2, $4);
		delete $2;
	}

lambda_body
	: expression
	| KeywordPass
	{
		$$ = new EmptyAST();
	}

conditional_expression
	: bool_or_expression
	| bool_or_expression '?' bool_or_expression ':' bool_or_expression
	{
		$$ = new IfStatementAST($1, $3, $5);
	}

bool_or_expression
	: bool_and_expression
	| bool_or_expression KeywordOr bool_and_expression
	{
		$$ = new BinaryOpAST($1, $3, OpOr);
	}
	// | bool_or_expression OrShort bool_and_expression

bool_and_expression
	: bool_not_expression
	// | bool_and_expression KeywordAnd bool_not_expression
	// | bool_and_expression AndShort bool_not_expression

bool_not_expression
	: comparison_expression
	| KeywordNot bool_not_expression
	{
		$$ = new NotAST($2);
	}
	| '!' bool_not_expression
	{
		$$ = new NotAST($2);
	}

comparison_expression
	: range_expression
	| comparison_expression '>' range_expression
	{
		$$ = new BinaryOpAST($1, $3, OpGreater);
	}
	| comparison_expression '<' range_expression
	{
		$$ = new BinaryOpAST($1, $3, OpLess);
	}
	| comparison_expression LessThan range_expression
	{
		$$ = new BinaryOpAST($1, $3, OpLessOrEqual);
	}
	| comparison_expression MoreThan range_expression
	{
		$$ = new BinaryOpAST($1, $3, OpGreaterOrEqual);
	}
	| comparison_expression Equal range_expression
	{
		$$ = new BinaryOpAST($1, $3, OpEqual);
	}
	| comparison_expression NotEqual range_expression
	{
		$$ = new BinaryOpAST($1, $3, OpNotEqual);
	}

range_expression
	: or_expression
	// | or_expression RangeOpen or_expression
	// | or_expression RangeClose or_expression

or_expression
	: xor_expression
	// | or_expression '|' xor_expression

xor_expression
	: and_expression
	// | xor_expression '^' and_expression

and_expression
	: shift_expression
	// | and_expression '&' shift_expression

shift_expression
	: addition_expression
	// | shift_expression LeftShift addition_expression
	// | shift_expression RightShift addition_expression

addition_expression
	: multiplication_expression
	| addition_expression '+' multiplication_expression
	{
		$$ = new BinaryOpAST($1, $3, OpAdd);
	}
	| addition_expression '-' multiplication_expression
	{
		$$ = new BinaryOpAST($1, $3, OpSub);
	}
	// | addition_expression '~' multiplication_expression

multiplication_expression
	: unary_expression
	| multiplication_expression '*' unary_expression
	{
		$$ = new BinaryOpAST($1, $3, OpMul);
	}
	// | multiplication_expression IntDivide unary_expression
	| multiplication_expression '/' unary_expression
	{
		$$ = new BinaryOpAST($1, $3, OpDiv);
	}
	| multiplication_expression '%' unary_expression
	{
		$$ = new BinaryOpAST($1, $3, OpMod)
	}

unary_expression
	: power_expression
	// | Increment unary_expression
	// | Decrement unary_expression
	// | '-' unary_expression
	// | '+' unary_expression
	// | '~' unary_expression

power_expression
	: callref_expression
	// | power_expression Power callref_expression

callref_expression
	: postfix_expression
	// | KeywordRef postfix_expression

postfix_expression
	: primary
	// | postfix_expression '.' identifier_all
	// | postfix_expression Increment
	// | postfix_expression Decrement
	| KeywordNew class_name
	{
		$$ = new CreateInstanceAST(*$2);
		delete $2;
	}
	| postfix_expression '(' ')'
	{
			vector<AST *> empty;
			$$ = new CallAST($1, empty);
	}
	| postfix_expression '(' argument_list ')'
	{
			$$ = new CallAST($1, *$3);
	}
	// | postfix_expression '[' ']'
	// | postfix_expression '[' argument_list ']'

argument_list
	: argument
	{
			vector<AST *> *args = new vector<AST *>();
			args->push_back($1);
			$$ = args;
	}
	| argument_list ',' argument
	{
			vector<AST *> *args = $1;
			args->push_back($3);
			$$ = args;
	}

argument
	: expression
	// | named_argument

// named_argument
// 	: identifier_all ':' expression

primary
	: identifier_all
	| literal
	| KeywordTrue
	{
		$$ = new BooleanLitAST(true);
	}
	| KeywordFalse
	{
		$$ = new BooleanLitAST(false);
	}
	| KeywordNil
	{
		$$ = new NilLitAST();
	}
	| '(' expression ')'
	{
		$$ = $2;
	}

literal
	: StringLiteral
	{
		$$ = new StringLitAST(*$1);
	}
	// | EmbedStringLiteral
	// | WysiwygStringLiteral
	// | ImaginaryNumber
	// {
	// 	$$ = new ImaginaryNumberLitAST($1);
	// }
	// | FloatNumber
	// {
	// 	$$ = new FloatNumberLitAST($1);
	// }
	| Integer
	{
		$$ = new IntegerLitAST($1);
	}

%%

void lury::Parser::error(const Parser::location_type& l, const std::string& m) {
	driver.error(l, m);
}
